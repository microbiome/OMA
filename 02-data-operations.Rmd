---
title: "Data operations"
author: "Sudarshan"
date: "11/4/2020"
output: html_document
---

# Data Operations  

Experimental and putting my thoughts (rough notes)
## Common terminologies  

The `mia` package uses classes defined by [`TreeSummarizedExperiment`](https://www.bioconductor.org/packages/release/bioc/html/TreeSummarizedExperiment.html), [`MicrobiomeExperiment`](https://github.com/FelixErnst/MicrobiomeExperiment) and in general [`SummarizedExperiment`](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html).  

`assays`     : Similar to `otu_table` in `phyloseq`. An `SummarizedExperiment` object 
               can hold multiple assays, raw counts, transformed counts. See also 
               [`MultiAssayExperiment`](https://bioconductor.org/packages/release/bioc/html/MultiAssayExperiment.html)   
`rowData`    : Slot similar to `tax_table` in `phyloseq`   
`colData`    : Slot similar to `sample_data` in `phyloseq`  
`rowTree`    : Slot for phylogenetic tree. Similar to `phy_tree` in `phyloseq`  
`FeatureIDs` : These are row names in `assays` and `rowData`. Synonymous to OTU/ASV ids.  
`SampleIDs`  : These are column names in `assays` and row names in `colData`.   


## Retrieving data elements  

Extract specific elements from `TreeSummarizedExperiment` and `MicrobiomeExperiment` object.    

```{r libs, message=FALSE}
library(mia)
library(dplyr)
library(ggplot2)
library(tibble)
library(pheatmap)
```

Example data  
```{r data}
data(GlobalPatterns, package = "MicrobiomeExperiment")
me <- GlobalPatterns 
```

Create a relative abundance assay
```{r rel-ab}
me <- relAbundanceCounts(GlobalPatterns)
me
```

Above there are now two `assays` 1] counts 2] relabundance

## Extract specific elements  

### Assays  
Assay slots hold the counts and transformed data for `FeatureIDs`
```{r assay-1}

me_counts <- assay(me, "counts")
me_counts[1:5,1:7]

```
Extract relative abundance data.  
```{r assay-2}
me_reab <- assay(me, "relabundance")
me_reab[1:5,1:7]
```

### colData  
Get colData as a data.frame.   
```{r coldata}
me_sample_data <- colData(me) %>% 
    as.data.frame()
# show select row and columns
me_sample_data[1:5,1:5]
```


### rowData  
Get rowData as a data.frame  
```{r rowdata}

me_row_data <- rowData(me) %>% 
    as.data.frame()
# show select row and columns
me_row_data[1:5,1:5]
```


### rowTree  
Get rowTree     
```{r rowtree}

me_row_tree <- rowTree(me) 
me_row_tree
```
Check link between rownames (OTU/ASV ids)
```{r rowlink}
# extract the linkData
# on rows
rowL <- rowLinks(x = me)
```

## Library size   

Get total counts/sample  
see `microbiome::readcount`.  

```{r lib-size}

reads_sample <- colSums(assay(me, "counts")) 
# add it to colData
colData(me)$reads_sample <- reads_sample

```

Visualize library size 
```{r viz-lib-size, fig.width=8, fig.height=4}
me_sample_data <- colData(me) %>% 
    as.data.frame() %>% 
    rownames_to_column("SampleId")

ggplot(me_sample_data, aes(reads_sample, SampleId)) +
    geom_col(aes(fill=SampleType)) +
    theme_bw() + # prettify plot
    theme(axis.text = element_text(size = 10), 
          axis.line.x = element_line(color = "#242424"), 
          axis.line.y = element_line(color = "#242424"), 
          panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
          panel.border = element_rect(colour = "#242424"), 
          legend.key = element_blank(), legend.text = element_text(color = "#353535"), 
          legend.background = element_rect(colour = NA, fill = NA))

```
  
## Agglomerate  

Agglomerate at a specific taxonomic rank. If multiple assays (counts and relabundance) exists, both will be agglomerated.  
```{r agglomerate-1}
me_fam <- agglomerateByRank(me, rank = "Family",
                        agglomerateTree = TRUE)

print(me_fam)
```

```{r agglomerate-2}
me_fam_reab <- assay(me_fam, "relabundance")
me_fam_reab[1:5,1:7]
```
  
```{r agglomerate-3}
me_fam_reab <- assay(me_fam, "counts")
me_fam_reab[1:5,1:7]
```

These data can also be kept in 

```{r altExp-1}
altExp(me, "family") <- me_fam
```
`altExpNames` now consists of `family` level data. This can be extended to use any level present in `r taxonomyRanks(me)`  

## Get unique  
Get which Phyla are present.  
```{r unique-1}
head(unique(rowData(me)[,"Phylum"]))
```
## Pick specific  
Retrieving of specific elements are required for specific analysis. For instance, extracting abundances for a specific taxa in all samples or all taxa in one sample.  

### Abundances of all taxa in specific sample 
```{r pick-sample}
#Note: getAbundanceSample()
taxa.abundances.cc1 <- assay(me)[, "CC1"]
taxa.abundances.cc1[1:10]

```

### Abundances of specific taxa in all samples   

```{r pick-feature}
#Note: getAbundanceFeature()
taxa.abundances <- assay(me)["255340",]
taxa.abundances[1:10]
```

## Join  

Joining otu/asv table and taxonomy in one data frame

```{r join-1}

me_reab <- assay(me, "relabundance") %>% 
    as.data.frame() %>% 
    rownames_to_column("FeatureID")

me_joined <- rowData(me) %>% 
    as.data.frame() %>% 
    rownames_to_column("FeatureID") %>% 
    left_join(me_reab) 

head(me_joined)

```

## Barplot  
As example we first `agglomerateByRank` to phylum level.  
```{r agg-phy}
me_phy <- agglomerateByRank(me, rank = "Phylum",
                        agglomerateTree = TRUE)
```

### Top taxa  
Define a function to get top taxa.   
Note: `getTopTaxa`  
```{r top-1}
getTopTaxa <- function(x, method=c("sum","mean","median"), top=5){
    taxs <- NULL
    if(method=="sum"){
        taxs <- sort(rowSums(assay(x)),decreasing = TRUE)[1:top]
    } else if (method=="mean"){
        taxs <- sort(rowMeans(assay(x)),decreasing = TRUE)[1:top]
    } else if (method=="median") {
        taxs <- rowMedians(assay(x))
        names(taxs) <- rownames(assay(x))
        taxs <- sort(taxs,decreasing = TRUE)[1:top]
    }
    return(names(taxs))
}
```

Get top 10 taxa  
```{r top-2}
top_phy <- getTopTaxa(me_phy, method="median", top=10)
top_phy
```

### Convert to long data.frame  

```{r ldf-1}

molten_se <- meltAssay(me_phy,
  add_row_data = TRUE,
  add_col_data = TRUE,
  abund_values = "relabundance"
)

```


### Barplot visualization    

A barplot of composition for top 10 phyla  

```{r barplot, eval=TRUE}
# Chage all not in top_phy to "Other" category
molten_se <- molten_se %>% 
    mutate(TaxVar= ifelse(FeatureID %in% top_phy, Phylum, "Other"))

p <- ggplot(molten_se, aes_string(x="SampleID", y="relabundance", fill="TaxVar")) +
    geom_bar(position="stack", stat="identity") +
    scale_x_discrete() + 
    labs(y = "Relative Abundance",x="") + 
    theme_bw() +
    theme(axis.text.x=element_text(angle=90, 
                                   hjust=0.95,
                                   vjust=0.2),
          panel.grid = element_blank(),
          legend.text = element_text(face="italic")) +
    scale_fill_brewer("Phylum",palette = "Paired") # this can be argument (fill.colors= "Paired") or something similar
p + scale_y_continuous(labels = scales::percent) # this can be optional (relative==TRUE) or something similar

```

## Get top taxa and taxonomy   

### Features  
Can we get taxonomic rank(s) for top features?
```{r top-feature-taxo}

top_features <- getTopTaxa(me, method="median", top=10)
tax_data <- rowData(me)[top_features,taxonomyRanks(me)]
tax_data %>% as.data.frame()

```

### Top Genera  
 
```{r top-gen}
me_gen <- agglomerateByRank(me, rank = "Genus",
                            agglomerateTree = TRUE)

top_genera <- getTopTaxa(me_gen, method="median", top=10)
top_genera
```
Since there are several taxa unclassified at Genus level, we get different taxonomic levels?  
It is a challenge to deal with high number of missing values within this hierarchical data, especially as we go to lower taxonomic ranks.   

## Taxonomic labels  

```{r tax-labels-1}
getTaxonomyLabels(me)[1:10]
```

Get assay and label best available taxonomic classification.   
```{r tax-labels-2}
feature_tab <- assay(me, "counts")

# change IDs to best available taxonomic classification
rownames(feature_tab) <- getTaxonomyLabels(me)
feature_tab[1:6,1:6]
```

How can we store this ? or Change rownames in rowData and assays to use best taxonomic classification instead of some non-informative IDs e.g. "549656","331820" or "ASV001", "ASV002" ?  

Check heatmap  
```{r tax-labels-heatmap-1}

pheatmap(feature_tab[26:50,1:20])

```

Without processing  

```{r tax-labels-heatmap-2}
pheatmap(assay(me, "counts")[26:50,1:20])
```

First heatmap is more informative than second.  

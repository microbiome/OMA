## Introductory (French)

<div id="workflow">

<div id="translate">
  <a href="Introductory-workflow.html"><img src="images/profile-pics/GB_flag.png" alt="Great Britain flag" class="profilepic"/> **English** </a>
  <a href="Introductory-workflow-dutch-version.html"><img src="images/profile-pics/Netherland_flag.jpg" alt="Netherland flag" class="profilepic"/> **Dutch** </a>
</div>

<img src="images/intro_workflow_logo.svg" alt="logo workflow" id="banner"/>

# Introduction

Bonjour et bienvenue dans un workflow complet utilisant les derniers outils R/Bioconductor pour la science des donn√©es du microbiome. Dans ce tutoriel, nous vous guiderons √† travers quelques √©tapes de base d'une √©tude d'analyse de composition utilisant OMA. Celles-ci seront applicables √† presque tous vos projets et vous aideront √† comprendre les concepts fondamentaux qui propulseront üöÄ vos futures analyses du microbiome.

# Importation des donn√©es

Lors de l'utilisation de packages pour le microbiome, il existe de nombreuses fa√ßons diff√©rentes d'importer vos donn√©es. Commen√ßons par charger les packages requis:

```{r setup}
#| output: FALSE
# List of packages that we need
packages <- c(
    "ggplot2", "knitr", "mia", "dplyr", "miaViz", "vegan", "DT",
    "scater", "patchwork", "sechm", "plotly"
    )

# Get packages that are already installed installed
packages_already_installed <- packages[ packages %in% installed.packages() ]

# Get packages that need to be installed
packages_need_to_install <- setdiff( packages, packages_already_installed )

# Loads BiocManager into the session. Install it if it not already installed.
if( !require("BiocManager") ){
    install.packages("BiocManager")
    library("BiocManager")
}

# If there are packages that need to be installed, installs them with BiocManager
# Updates old packages.
if( length(packages_need_to_install) > 0 ) {
   install(packages_need_to_install, ask = FALSE)
}

# Load all packages into session. Stop if there are packages that were not
# successfully loaded
pkgs_not_loaded <- !sapply(packages, require, character.only = TRUE)
pkgs_not_loaded <- names(pkgs_not_loaded)[ pkgs_not_loaded ]
if( length(pkgs_not_loaded) > 0 ){
    stop("Error in loading the following packages into the session: '", paste0(pkgs_not_loaded, collapse = "', '"), "'")
}
```

Vous pouvez choisir d'utiliser vos propres donn√©es ou l'un des ensembles de donn√©es int√©gr√©s fournis par mia que vous trouverez ici @sec-example-data:

Dans ce tutoriel, nous utiliserons l'ensemble de donn√©es @Tengeler2020. Cet ensemble de donn√©es a √©t√© cr√©√© par A.C. Tengeler pour essayer de d√©montrer l'impact des microbiomes alt√©r√©s sur la structure du cerveau. Voici comment nous pouvons charger les donn√©es dans notre environnement R :

```{r}
#| label: loadDataset
data("Tengeler2020", package="mia")
tse <- Tengeler2020
```

Bien s√ªr, il existe d'autres moyens d'importer vos donn√©es en utilisant le [**package mia**](https://microbiome.github.io/mia/). Ceux-ci incluent : utiliser **vos propres donn√©es** ([@sec-import-from-file]) ou convertir un objet existant en un objet *TreeSummarizedExperiment* comme indiqu√© dans **cette section** : [@sec-conversions-between-data-formats-in-r].

<hr>

# Stockage des donn√©es du microbiome

*TreeSummarizedExperiment* ou objet TreeSE est le type d'objet utilis√© dans le [**package mia**](https://microbiome.github.io/mia/) pour stocker vos donn√©es. C'est un type de donn√©es polyvalent et multi-usages qui permet de stocker et d'acc√©der aux donn√©es de mani√®re efficace.

Voici un rappel rapide sur la fa√ßon d'acc√©der √† certains types de donn√©es :

Vous pouvez acc√©der aux assays  **assays** ([@sec-assay-slot]) de cette mani√®re :

```{r}
#| label: showAssay
assay(tse)[1:5,1:10] 
```

Alors que **colData** ([@sec-add-or-modify-data]) est accessible via :

```{r}
#| label: showColdata
# Transform the colData to a dataframe
tse_df_colData <- as.data.frame(colData(tse))

# Show as an interactive table
datatable(tse_df_colData,options = list(pageLength = 5),rownames = FALSE)
```

**rowData** ([@sec-rowData]) contient des donn√©es sur les caract√©ristiques des √©chantillons, notamment des informations taxonomiques.

```{r}
#| warning: FALSE
#| label: showRowdata
tse_df_rowData <- as.data.frame(rowData(tse))
datatable(tse_df_rowData, options = list(pageLength = 5))
```

Ici `rowData(tse)` renvoie un DataFrame avec 151 lignes et 7 colonnes. Chaque ligne repr√©sente un organisme et chaque colonne un niveau taxonomique.

Pour illustrer la structure d'un *TreeSummarizedExperiment*, voici un article de @Huang2021 qui utilise ce type d'objet. De plus, veuillez consulter la figure 1 ci-dessous.

![1. Storing microbial data: the structure of a TreeSummarizedExperiment](images/TSE-structure.svg){.lightbox .contentimg}

<hr>

# Manipulation des donn√©es

Dans certains cas, vous devrez peut-√™tre modifier vos donn√©es pour obtenir les r√©sultats souhait√©s. Dans cette section, nous verrons comment agglom√©rer les donn√©es, les sous-ensembles et plus encore. Un TreeSummarizedExperiment permet une manipulation astucieuse des donn√©es en utilisant le [**package dplyr**](https://dplyr.tidyverse.org/).

## Sous-ensembles

Dans certains cas, vous n'aurez peut-√™tre besoin d'utiliser qu'une partie de votre *TreeSummarizedExperiment* d'origine.

En utilisant l'ensemble de donn√©es Tengeler2020, nous pouvons nous concentrer sur une certaine cohorte par exemple. Cela est assez simple :

```{r}
#| label: subsetBySample
tse_subset_by_sample <- tse[ , tse$cohort =="Cohort_1"]
```

Cela cr√©era un objet *TreeSummarizedExperiment* ne contenant que les √©chantillons de la premi√®re cohorte.

## Agglom√©ration des donn√©es

Pour pousser davantage votre analyse de donn√©es et vous concentrer sur sa distribution √† un rang taxonomique sp√©cifique, il peut √™tre b√©n√©fique d'agglom√©rer vos donn√©es √† ce niveau particulier. La fonction agglomerateByRank simplifie ce processus, permettant des analyses plus fluides et efficaces. Voici un exemple :

```{r}
#| label: agglomerating-data
tse.agglomerated <- agglomerateByRank(tse, rank='Phylum')

# Check
datatable(data.frame(rowData(tse.agglomerated)),options = list(pageLength = 5),rownames = FALSE)
```

G√©nial ! Maintenant, nos donn√©es sont confin√©es aux informations taxonomiques jusqu'au niveau du Phylum, permettant √† l'analyse de se concentrer sur ce rang sp√©cifique. Dans le reste du workflow, nous n'utiliserons pas les donn√©es agglom√©r√©es, mais tout le code ci-dessous peut √™tre utilis√© sur celles-ci.

# Indicateurs

## Diversit√© de la communaut√©

La diversit√© de la communaut√© en microbiologie est mesur√©e par plusieurs indices :
-   la richesse en esp√®ces (nombre total d'esp√®ces)
-   l'√©quitabilit√© (r√©partition des esp√®ces au sein d'un microbiome)
-   la diversit√© (combinaison des deux)

Le **coefficient de @Hill** combine ces mesures en une seule √©quation. Toutes ces variations sont appel√©es diversit√© alpha.

```{r}
#| label: calculateRichness

# Estimate (observed) richness
tse_alpha <- estimateRichness(tse, 
                             assay.type = "counts", 
                             index = "observed", 
                             name="observed")

# Check some of the first values in colData
head(tse_alpha$observed)
```

Le r√©sultat montre les valeurs de richesse estim√©es pour diff√©rents √©chantillons ou emplacements au sein de l'ensemble de donn√©es. Il donne une id√©e de la diversit√© de chaque √©chantillon en termes de nombre d'esp√®ces diff√©rentes pr√©sentes. Nous pouvons ensuite cr√©er un graphique pour visualiser cela.

```{r}
#| label: plotColdata
plotColData(tse_alpha, 
            "observed", 
            "cohort", 
            colour_by = "patient_status") +
  theme(axis.text.x = element_text(angle=45,hjust=1)) + 
  labs(y=expression(Richness[Observed]))
```

Pour aller encore plus loin, nous pouvons √©galement comparer l'indice de Shannon estim√© √† la richesse observ√©e. Shannon quantifie la diversit√© en termes √† la fois du nombre d'esp√®ces diff√©rentes (richesse) et de l'uniformit√© de leur r√©partition (abondance) et est calcul√© comme suit :

$$
H' = -\sum_{i=1}^{R} p_i \ln(p_i)
$$ p~i~ √©tant la proportion d'un certain microorganisme.

<hr>

D'abord, nous pouvons facilement calculer cette mesure et l'ajouter √† notre TreeSE.

```{r}
#| label: calculateDiversity
tse_alpha <- estimateDiversity(tse_alpha, 
                              assay.type = "counts",
                              index = c("shannon"), 
                              name = c("shannon"))
```

Nous pouvons √©galement comparer les deux mesures de diversit√© en produisant les graphiques suivants.

```{r}
#| label: violinPlots

# Create the plots
plots <- lapply(c("observed", "shannon"),
                plotColData,
                object = tse_alpha,
                x = "patient_status",
                colour_by = "patient_status")

# Fine-tune visual appearance
plots <- lapply(plots, "+", 
                theme(axis.text.x = element_blank(),
                      axis.title.x = element_blank(),
                      axis.ticks.x = element_blank()))

# Plot the figures
(plots[[1]] | plots[[2]]) +
  plot_layout(guides = "collect")

```

Il est tr√®s important de faire toutes ces comparaisons afin de quantifier la diversit√© et de comparer les √©chantillons dans nos donn√©es en utilisant diff√©rentes mesures. - Vous pouvez trouver d'autres types de comparaisons directement dans le livre @sec-community-diversity.

<hr>

## Similarit√© de la communaut√©

La similarit√© de la communaut√© fait r√©f√©rence √† la mani√®re dont les microorganismes se ressemblent en termes de composition et d'abondance des diff√©rents taxons microbiens. Cela peut nous aider √† comprendre dans quelle mesure diff√©rents √©chantillons se ressemblent et √† trouver des informations cl√©s. Cependant, en analyse de microbiome, il est plus courant de mesurer la dissimilarit√©/diversit√© b√™ta entre deux √©chantillons A et B en utilisant la mesure de Bray-Curtis qui est d√©finie comme suit :

$$
BC_{ij} = \frac{\sum_{k} |A_{k} - B_{k}|}{\sum_{k} (A_{k} + B_{k})}
$$ Heureusement pour nous, le [**package mia**](https://microbiome.github.io/mia/) fournit un moyen facile de calculer l'abondance relative pour notre TreeSE en utilisant la m√©thode transformAssay.

```{r}
#| label: calculateRelabundance
tse <- transformAssay(tse,
                      assay.type = "counts",
                      method = "relabundance")
```
Cela prendra l'assay des comptes d'origine et appliquera le calcul des abondances relatives. Le r√©sultat est une matrice avec les identifiants des √©chantillons en lignes et les abondances relatives pour chaque taxon dans ces √©chantillons en colonnes. Il peut √™tre consult√© dans les assays du tse :

```{r}
#| label: showRelabundance
assay(tse, "relabundance")[5:10,1:10]
```


Ensuite, nous pouvons ajouter la dissimilarit√© de Bray-Curtis :

```{r}
#| label: calculateBrayCurtis
#| output: false

# Run PCoA on relabundance assay with Bray-Curtis distances
tse <- runMDS(tse,
              FUN = vegdist,
              method = "bray",
              assay.type = "relabundance",
              name = "MDS_bray")
```

Dans notre cas, l'assay contient 151 lignes et 27 colonnes. Avoir autant de colonnes et donc de dimensions peut √™tre probl√©matique pour visualiser la dissimilarit√©.

Pour visualiser la dissimilarit√© entre les diff√©rents √©chantillons, nous pouvons effectuer une analyse en coordonn√©es principales sur l'assay nouvellement cr√©√©. Cela projette essentiellement les dimensions de Bray-Curtis sur un espace inf√©rieur tout en conservant autant de variation que possible, les valeurs projet√©es √©tant appel√©es coordonn√©es principales. Vous pouvez en lire plus sur @Multidimensional-scaling ici.

mia fournit certaines techniques de r√©duction de dimension, telles que dbRDA. De plus, nous pouvons utiliser le package scater de Bioconductor et le package vegan, cr√©√© par @R_vegan pour transformer la dissimilarit√© en distances r√©elles pouvant √™tre visualis√©es :

```{r}
#| label: showPCoA
# Create ggplot object
p <- plotReducedDim(tse, "MDS_bray") +
  geom_point(color = "#659b91")

# Convert to an interactive plot with ggplotly
ggplotly(p)
```

Cependant, les axes ne sont pas tr√®s informatifs et la quantit√© de variance captur√©e par l'algorithme n'est nulle part indiqu√©e. Nous pouvons ajuster le graphique pour montrer plus d'informations comme suit :

```{r}
#| label: addVariancePCoA
# Calculate explained variance
e <- attr(reducedDim(tse, "MDS_bray"), "eig")
rel_eig <- e / sum(e[e > 0])

# Add explained variance for each axis on the plot
p <- p + labs(x = paste("PCoA 1 (", round(100 * rel_eig[[1]], 1), "%", ")", sep = ""),
              y = paste("PCoA 2 (", round(100 * rel_eig[[2]], 1), "%", ")", sep = ""))

# Reonvert to an interactive plot with ggplotly
ggplotly(p)
```

Et voil√† ! Chaque axe montre la quantit√© de variance ou dans notre cas de dissimilarit√© retenue par chaque coordonn√©e principale. Vous pouvez √©galement ajouter d'autres options pour colorier par une certaine caract√©ristique par exemple. Vous pouvez en savoir plus dans [@sec-community-similarity].

<hr>

# Visualisation des donn√©es

Les cartes de chaleurs sont l'un des moyens les plus polyvalents de visualiser vos donn√©es. Dans cette section, nous verrons comment cr√©er une heatmap de base pour visualiser les caract√©ristiques les plus r√©pandues en utilisant la [**biblioth√®que sechm**](https://bioconductor.org/packages/release/bioc/html/sechm.html). Pour une carte de chaleur plus d√©taill√©e, veuillez vous reporter √† **cette section** [@sec-multi-assay-analyses].

Ensuite, nous allons cr√©er un sous-ensemble de TreeSE pour les taxons les plus r√©pandus en utilisant une exp√©rience alternative :

```{r}
#| label: most-prevalent
altExp(tse, "prevalence-subset") <- subsetByPrevalent(tse,prevalence=0.5)[1:5,]
```

Lors de la cr√©ation de sous-ensembles avec cette fonction, l'objet r√©sultant ne contient plus les abondances relatives correctes car ces abondances ont √©t√© calcul√©es √† l'origine sur la basees donn√©es compl√®tes. Par cons√©quent, il est essentiel de recalculer les abondances relatives pour notre sous-ensemble :

```{r}
#| label: recalculate-relabundance
altExp(tse, "prevalence-subset") <- transformAssay(altExp(tse,                                                "prevalence-subset"),
                                       assay.type = "counts",
                                       method = "relabundance")
```

Now that we have prepared the data, we can use the previously loaded sechm library to plot the heatmap:

```{r}
#| label: heatmap
# Sets the colors
#setSechmOption("hmcols", value=c("#F0F0FF","#007562"))

# Plots the actual heatmap.
#sechm(altExp(tse, "prevalence-subset"), features =
#      rownames(rowData(altExp(tse, "prevalence-subset"))),
#      assayName="relabundance",show_colnames=TRUE)
```

In the heatmap above, it is apparent that Parabacteroides are relatively common in some samples while Akkermansia is detected very seldom.

</div>
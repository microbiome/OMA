# Extra material {#extras}

## PERMANOVA comparison

Here we present two possible uses of the `adonis2` function which performs PERMANOVA. The
optional argument `by` has an effect on the statistical outcome, so its two options are
compared in this section.

```{r permanova_import, warning = FALSE, message = FALSE}
# import necessary packages
if (!require(gtools)){
  install.packages("gtools")  
}
if (!require(purrr)){
  install.packages("purrr")  
}
library(vegan)
library(gtools)
library(purrr)
```

Below we load the _enterotype_ TSE object and run PERMANOVA with the `adonis2` function
for different orders of the three variables ClinicalStatus, Gender and Nationality with
two different approaches: `by = "margin"` or `by = "terms"`.


```{r permanova_prep, message = FALSE, warning = FALSE}
# load and prepare data
data("enterotype")
enterotype <- transformCounts(enterotype, method = "relabundance")
# drop samples missing meta data
enterotype <- enterotype[ , !rowSums(is.na(colData(enterotype)[, c("Nationality", "Gender", "ClinicalStatus")]) > 0)]
# define variables and list all possible combinations
vars <- c("Nationality", "Gender", "ClinicalStatus")
var_perm <- permutations(n = 3, r = 3, vars)
formulas <- apply(var_perm, 1, function(row) purrr::reduce(row, function(x, y) paste(x, "+", y)))
# create empty data.frames for further storing p-values
terms_df <- data.frame("Formula" = formulas,
                       "ClinicalStatus" = rep(0, 6),
                       "Gender" = rep(0, 6),
                       "Nationality" = rep(0, 6))
margin_df <- data.frame("Formula" = formulas,
                        "ClinicalStatus" = rep(0, 6),
                        "Gender" = rep(0, 6),
                        "Nationality" = rep(0, 6))
```



```{r permanova_loop, message = FALSE, warning = FALSE}
for (row_idx in 1:nrow(var_perm)) {
  
  # generate temporary formula (i.e. "assay ~ ClinicalStatus + Nationality + Gender")
  tmp_formula <- purrr::reduce(var_perm[row_idx, ], function(x, y) paste(x, "+", y))
  tmp_formula <- as.formula(paste0('t(assay(enterotype, "relabundance")) ~ ',
                            tmp_formula))

  # multiple variables, default: by = "terms"
  set.seed(75)
  with_terms <- adonis2(tmp_formula, 
                by = "terms",
                data = colData(enterotype),
                permutations = 99)
  
  # multiple variables, by = "margin"
  set.seed(75)
  with_margin <- adonis2(tmp_formula, 
                 by = "margin",
                 data = colData(enterotype),
                 permutations = 99)

  # extract p-values
  terms_p <- with_terms[["Pr(>F)"]]
  terms_p <- terms_p[!is.na(terms_p)]
  margin_p <- with_margin[["Pr(>F)"]]
  margin_p <- margin_p[!is.na(margin_p)]
  
  # store p-values into data.frames
  for (col_idx in 1:ncol(var_perm)) {
    
    terms_df[var_perm[row_idx, col_idx]][row_idx, ] <- terms_p[col_idx]
    margin_df[var_perm[row_idx, col_idx]][row_idx, ] <- margin_p[col_idx]
    
  }
  
}
```




The following table displays the p-values for the three variables ClinicalStatus, Gender and
Nationality obtained by PERMANOVA with `adonis2`. As you can see, p-values remain identical when
`by = "margin"`, but they change with the order of the variables in the formula when `by = "terms"` (default).

```{r permanova_table, message = FALSE, warning = FALSE}

df <- terms_df %>%
  dplyr::inner_join(margin_df, by = "Formula", suffix = c(" (terms)", " (margin)"))

knitr::kable(df)
```


## Bayesian Multinomial Logistic-Normal Models

Analysis using such model could be performed with the function `pibble` from the `fido`
package, wihch is in form of a Multinomial Logistic-Normal Linear Regression model; see
[vignette](https://jsilve24.github.io/fido/articles/introduction-to-fido.html) of package.


The following presents such an exemplary analysis based on the 
data of @Sprockett2020 available
through `microbiomeDataSets` package.


```{r, message=FALSE, warning=FALSE}
if (!require(fido)){
  # installing the fido package
  devtools::install_github("jsilve24/fido")
}
```

Loading the libraries and importing data:

```{r, message=FALSE, warning=FALSE}
library(fido)
```

```{r, message=FALSE, warning=FALSE, eval=FALSE}
library(microbiomeDataSets)
tse <- SprockettTHData()
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
# saveRDS(tse, file="data/SprockettTHData.Rds")
# Hidden reading of the saved data
tse <- readRDS("data/SprockettTHData.Rds")
```


We pick three covariates ("Sex","Age_Years","Delivery_Mode") during this
analysis as an example, and beforehand we check for missing data:


```{r, message=FALSE, warning=FALSE}
cov_names <- c("Sex","Age_Years","Delivery_Mode")
na_counts <- apply(is.na(colData(tse)[,cov_names]), 2, sum)
na_summary<-as.data.frame(na_counts,row.names=cov_names)
```

We drop missing values of the covariates:

```{r, message=FALSE, warning=FALSE}
tse <- tse[ , !is.na(colData(tse)$Delivery_Mode) ]
tse <- tse[ , !is.na(colData(tse)$Age_Years) ]
```

We agglomerate microbiome data to Phylum:

```{r, message=FALSE, warning=FALSE}
tse_phylum <- agglomerateByRank(tse, "Phylum")
```

We extract the counts assay and covariate data to build the model
matrix:

```{r, message=FALSE, warning=FALSE}
Y <- assays(tse_phylum)$counts
# design matrix
# taking 3 covariates
sample_data<-as.data.frame(colData(tse_phylum)[,cov_names])
X <- t(model.matrix(~Sex+Age_Years+Delivery_Mode,data=sample_data))
```

Building the parameters for the `pibble` call to build the model; see more at [vignette](https://jsilve24.github.io/fido/articles/introduction-to-fido.html):

```{r, message=FALSE, warning=FALSE}
n_taxa<-nrow(Y)
upsilon <- n_taxa+3
Omega <- diag(n_taxa)
G <- cbind(diag(n_taxa-1), -1)
Xi <- (upsilon-n_taxa)*G%*%Omega%*%t(G)
Theta <- matrix(0, n_taxa-1, nrow(X))
Gamma <- diag(nrow(X))
```

Automatically initializing the priors and visualizing their distributions:

```{r, message=FALSE, warning=FALSE}
priors <- pibble(NULL, X, upsilon, Theta, Gamma, Xi)
names_covariates(priors) <- rownames(X)
plot(priors, pars="Lambda") + ggplot2::xlim(c(-5, 5))
```

Estimating the posterior by including our response data `Y`.
Note: Some computational failures could occur (see [discussion](https://github-wiki-see.page/m/jsilve24/fido/wiki/Frequently-Asked-Questions))
the arguments `multDirichletBoot` `calcGradHess` could be passed in such case.

```{r, message=FALSE, warning=FALSE}
priors$Y <- Y 
posterior <- refit(priors, optim_method="adam", multDirichletBoot=0.5) #calcGradHess=FALSE
```

Printing a summary about the posterior:

```{r, message=FALSE, warning=FALSE}
ppc_summary(posterior)
```
Plotting the summary of the posterior distributions of the regression parameters:

```{r, message=FALSE, warning=FALSE}
names_categories(posterior) <- rownames(Y)
plot(posterior,par="Lambda",focus.cov=rownames(X)[2:4])
```

Taking a closer look at "Sex" and "Delivery_Mode":

```{r, message=FALSE, warning=FALSE}
plot(posterior, par="Lambda", focus.cov = rownames(X)[c(2,4)])
```
